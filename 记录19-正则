比较不错的教程
https://deerchao.net/tutorials/regex/regex.htm
MDN   查找特殊字符时使用
https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions
MSDN的正则教程
https://docs.microsoft.com/zh-cn/dotnet/standard/base-types/regular-expression-language-quick-reference

重点代码/标识符/等
    一.创建方式
        字面量
            在加载脚本后，正则表达式字面值提供正则表达式的编译.当正则表达式保持不变时，使用此方法可获得更好的性能.
        构造函数
            使用构造函数提供正则表达式的运行时编译.使用构造函数，当你知道正则表达式模式将会改变，或者你不知道模式，并从另一个来源，如用户输入.
            使用变量传入时必须使用构造函数.
            注意:创建后改变传入的字符串变量不会改变正则对象(非引用创建).
            在使用时需要将字符串中的\进行转义
        
    二.转义字符
        转义字符列表见MDN.
        常用的转义字符
            \       基础转义
            \n      换行
            \t      tab
            \xhh    与代码hh匹配字符(两个十六进制数字)  不常用 ASC码
            \uhhhh	与代码 hhhh 匹配字符(四个十六进制数字) 稍常用 unicode码 常用于匹配汉字.大多数汉字范围都位于4e00 9fa5之间
                    因此[\u4e00-\u9fa5]可匹配绝大多数汉字
                    
            [xyz]   一个字符集合。匹配方括号中的任意字符，包括转义序列。
                    你可以使用破折号（-）来指定一个字符范围。
                    对于点（.）和星号（*）这样的特殊符号在一个字符集中没有特殊的意义。
                    他们不必进行转义，不过转义也是起作用的。
                    注意[a-zA-Z](√)    [a-Z](×)
                        [0-9](√)      [0-10](×)
                    
            [^xyz]  一个反向字符集。也就是说， 它匹配任何没有包含在方括号中的字符。
                    你可以使用破折号（-）来指定一个字符范围。
                    任何普通字符在这里都是起作用的。
                    
            .       (小数点)匹配除换行符之外的任何单个字符.等价于[^\n]
            \w      匹配一个单字字符（字母、数字或者下划线）.等价于[A-Za-z0-9_]
            \W      匹配一个非单字字符.等价于[^A-Za-z0-9_]
            \d      匹配一个数字.等价于[0-9]
            \D      匹配一个非数字字符.等价于[^0-9]
            \s      匹配一个空白字符,包括空格,制表符,换页符和换行符.
                    等价于[\f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]
            \S      匹配一个非空白字符.
                    等价于[^\f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]
                    
            {n,m}   n和m都是整数.匹配前面的字符至少n次,最多m次.如果n或者m的值是0,这个值被忽略.
                    注意:和m之间不能有空格
                         {1,}(√)     {,2}(×) 不合法
                         
            ?       匹配前面一个表达式0次或者1次.等价于{0,1}
                    如果紧跟在任何量词 *  + ? 或 {} 的后面,将会使量词变为非贪婪的（匹配尽量少的字符）,
                    和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。
            +       匹配前面一个表达式1次或者多次.等价于 {1,}.
            *       匹配前面一个表达式1次或者多次.等价于 {0,}.
            x|y     匹配'x'或者'y'.从x开始匹配,一旦x匹配成功就忽略y.匹配时同样遵循最先开始的匹配拥有最高的优先权.
            (x)     匹配'x'并且记住匹配项.括号被称为捕获括号.
                    模式/(foo)(bar)\1\2/中的'(foo)'和'(bar)'匹配并记住字符串"foo bar foo bar"中前两个单词。
                    模式中的\1和\2匹配字符串的后两个单词.
                    
                    注意\1,\2,\n是用在正则表达式的匹配环节.
                    在正则表达式的替换环节,则要使用像$1,$2,$n这样的语法,例如,'bar foo'.replace(/(...) (...)/,'$2 $1').
            (?:x)   匹配'x'但是不记住匹配项.这种叫作非捕获括号,使得你能够定义为与正则表达式运算符一起使用的子表达式.
                    来看示例表达式/(?:foo){1,2}/.如果表达式是/foo{1,2}/,{1,2}将只对'foo'的最后一个字符'o'生效.
                    如果使用非捕获括号,则{1,2}会匹配整个 ‘foo’ 单词.
                    
            ^       匹配输入的开始.如果多行标志被设置为true,那么也匹配换行符后紧跟的位置.
                    注意对空格无效
            $       匹配输入的结束.如果多行标示被设置为true,那么也匹配换行符前的位置.
                    


            贪婪匹配与非贪婪匹配的匹配规则
                a.*?b匹配最短的,以a开始,以b结束的字符串.如果把它应用于aabab的话,它会匹配aab(第一到第三个字符)和ab(第四到第五个字符)
                为什么第一个匹配是aab(第一到第三个字符)而不是ab(第二到第三个字符)?
                简单地说,因为正则表达式有另一条规则,
                比懒惰/贪婪规则的优先级更高:最先开始的匹配拥有最高的优先权——The match that begins earliest wins.
            
            分组和引用
                较为复杂,讲解得较好的见https://deerchao.net/tutorials/regex/regex.htm教程==>后向引用
                
                
                
    三.方法
        .exec() 如果匹配成功,exec()方法返回一个数组,并更新正则表达式对象的属性.
                返回的数组将完全匹配成功的文本作为第一项,将正则括号里匹配成功的作为数组填充到后面.
                如果匹配失败,exec()方法返回null.
                它会改变regexp对象的属性,具体属性改变列表见MDN  
                https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec
