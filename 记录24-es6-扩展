1.字符串扩展
        http://es6.ruanyifeng.com/#docs/string
                模板字符串
                        https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/template_strings
                        模板字面量 是允许嵌入表达式的字符串字面量。你可以使用多行字符串和字符串插值功能。
                        它们在ES2015规范的先前版本中被称为“模板字符串”。
                        
                        模板字符串使用反引号 (` `) 来代替普通字符串中的用双引号和单引号。
                        模板字符串可以包含特定语法（${expression}）的占位符。
                        占位符中的表达式和周围的文本会一起传递给一个默认函数，该函数负责将所有的部分连接起来，
                        如果一个模板字符串由表达式开头，则该字符串被称为带标签的模板字符串，该表达式通常是一个函数，
                        它会在模板字符串处理后被调用，在输出最终结果前，你都可以通过该函数来对模板字符串进行操作处理。
                        在模版字符串内使用反引号（`）时，需要在它前面加转义符（\）。
                        
                        如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。
                        $('#list').html(`
                        <ul>
                          <li>first</li>
                          <li>second</li>
                        </ul>
                        `);
                        上面代码中，所有模板字符串的空格和换行，都是被保留的，
                        比如<ul>标签前面会有一个换行。如果你不想要这个换行，可以使用trim方法消除它。
                        $('#list').html(`
                        <ul>
                          <li>first</li>
                          <li>second</li>
                        </ul>
                        `.trim());
                        
                字符串新增方法
                        重要方法:
                        .padStart()
                        padStart() 方法用另一个字符串填充当前字符串(重复，如果需要的话)，以便产生的字符串达到给定的长度。
                        填充从当前字符串的开始(左侧)应用的。
                        示例
                        'abc'.padStart(6,"123465"); // "123abc"
                        
                        .padEnd()
                        padEnd()  方法会用一个字符串填充当前字符串（如果需要的话则重复填充），返回填充后达到指定长度的字符串。
                        从当前字符串的末尾（右侧）开始填充。
                        'abc'.padEnd(11, "123456"); // "abc12345612"
                        
                        .repeat();
                        repeat() 构造并返回一个新字符串，该字符串包含被连接在一起的指定数量的字符串的副本。
                        let resultString = str.repeat(count);
                        重复次数不能为负数
                        重复次数必须小于 infinity，且长度不会大于最长的字符串。
                        "abc".repeat(1)      // "abc"
                        传入0变为空字符串
                        
                        includes()：返回布尔值，表示是否找到了参数字符串。
                        startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。
                        endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。
                        
                        let s = 'Hello world!';
                        s.startsWith('Hello') // true
                        s.endsWith('!') // true
                        s.includes('o') // true
                        这三个方法都支持第二个参数，表示开始搜索的位置。

                        let s = 'Hello world!';
                        s.startsWith('world', 6) // true
                        s.endsWith('Hello', 5) // true
                        s.includes('Hello', 6) // false
                        上面代码表示，使用第二个参数n时，endsWith的行为与其他两个方法有所不同。
                        它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。
                
                
                for...of
                        MDN
                        https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of
                        
                        http://es6.ruanyifeng.com/#docs/iterator
                        
                        ES6 借鉴 C++、Java、C# 和 Python 语言，引入了for...of循环，作为遍历所有数据结构的统一的方法。
                        一个数据结构只要部署了Symbol.iterator属性，就被视为具有 iterator 接口，就可以用for...of循环遍历它的成员。
                        也就是说，for...of循环内部调用的是数据结构的Symbol.iterator方法。
                        for...of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）
                        、后文的 Generator 对象，以及字符串。
                        
                
                unicode表示法
                        只要将码点放入大括号，就能正确解读该字符。
                        http://es6.ruanyifeng.com/#docs/string
                        "\u{20BB7}"
                        // "𠮷"
                        "\u{41}\u{42}\u{43}"
                        // "ABC"
                        
                condePointAt
                        http://es6.ruanyifeng.com/#docs/string-methods
                        ES6 提供了codePointAt()方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。
                        codePointAt()方法返回的是码点的十进制值，如果想要十六进制的值，可以使用toString()方法转换一下。
                        let s = '𠮷a';
                        s.codePointAt(0).toString(16) // "20bb7"
                        s.codePointAt(2).toString(16) // "61"
                        codePointAt()方法的参数，仍然是不正确的。比如，上面代码中，字符a在字符串s的正确位置序号应该是 1，
                        但是必须向codePointAt()方法传入 2。解决这个问题的一个办法是使用for...of循环，
                        因为它会正确识别 32 位的 UTF-16 字符。
                        let s = '𠮷a';
                        for (let ch of s) {
                          console.log(ch.codePointAt(0).toString(16));
                        }
                        
                        
                String.prototype.at()
                        获取指定下表的unicode值
                        es6的提案,暂时查不到具体消息,有可转化为es3的插件可以使用
                        https://github.com/es-shims/String.prototype.at

2.正则扩展
        http://es6.ruanyifeng.com/#docs/regex
                ES5 不允许此时使用第二个参数添加修饰符，否则会报错。
                var regex = new RegExp(/xyz/, 'i');//报错
                ES6 改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。
                而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。
                
                u修饰符
                        ES6 对正则表达式添加了u修饰符，含义为“Unicode 模式”，用来正确处理大于\uFFFF的 Unicode 字符。
                        也就是说，会正确处理四个字节的 UTF-16 编码。
                        /^\uD83D/u.test('\uD83D\uDC2A') // false
                        /^\uD83D/.test('\uD83D\uDC2A') // true
                        上面代码中，\uD83D\uDC2A是一个四个字节的 UTF-16 编码，代表一个字符。
                        但是，ES5 不支持四个字节的 UTF-16 编码，会将其识别为两个字符，导致第二行代码结果为true。
                        加了u修饰符以后，ES6 就会识别其为一个字符，所以第一行代码结果为false。
                        一旦加上u修饰符号，就会修改下面这些正则表达式的行为。
                
                y修饰符
                        除了u修饰符，ES6 还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。
                        y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。
                        不同之处在于，g修饰符只要剩余位置中存在匹配就可，
                        而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。
                
3.数值扩展
        http://es6.ruanyifeng.com/#docs/number
                二进制,八进制表示法
                        ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。
                        
                Number.parseInt(),Number.parseFloat()
                        ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。
                        这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。
                        
                Number.isFinite(),Number.isNaN()
                        ES6 在Number对象上，新提供了Number.isFinite()和Number.isNaN()两个方法。
                        Number.isFinite()用来检查一个数值是否为有限的（finite），即不是Infinity。
                        注意，如果参数类型不是数值，Number.isFinite一律返回false。
                        
                        Number.isNaN()用来检查一个值是否为NaN。
                        如果参数类型不是NaN，Number.isNaN一律返回false。
                        它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，
                        再进行判断，而这两个新方法只对数值有效，Number.isFinite()对于非数值一律返回false, 
                        Number.isNaN()只有对于NaN才返回true，非NaN一律返回false。
                        
                安全整数
                        JavaScript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。
                        ES6 引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。
                        Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。
                        
                指数运算符
                        ES2016 新增了一个指数运算符（**）。
                        这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的。
                        指数运算符可以与等号结合，形成一个新的赋值运算符（**=）。
                        注意，V8 引擎的指数运算符与Math.pow的实现不相同，对于特别大的运算结果，两者会有细微的差异。
                        Math.pow(99, 99)
                        // 3.697296376497263e+197
                        99 ** 99
                        // 3.697296376497268e+197
                        
4.函数扩展
                函数参数的默认值
                        ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。
                        ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。
                        参数默认值可以与解构赋值的默认值，结合起来使用。
                        使用参数默认值时，函数不能有同名参数。
                        另外，一个容易忽略的地方是，参数默认值不是传值的，
                        而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。
                        let x = 99;
                        function foo(p = x + 1) {
                          console.log(p);
                        }
                        foo() // 100
                        x = 100;
                        foo() // 101
                        
                        参数默认值可以与解构赋值的默认值，结合起来使用。
                        function fetch(url, { body = '', method = 'GET', headers = {} } = {}) {
                          console.log(method);
                        }
                        fetch('http://example.com')
                        // "GET"
                        上面代码中，函数fetch没有第二个参数时，函数参数的默认值就会生效，
                        然后才是解构赋值的默认值生效，变量method才会取到默认值GET。
                        
                rest参数
                        ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，
                        这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。
                        下面是一个 rest 参数代替arguments变量的例子。

                        // arguments变量的写法
                        function sortNumbers() {
                          return Array.prototype.slice.call(arguments).sort();
                        }
                        // rest参数的写法
                        const sortNumbers = (...numbers) => numbers.sort();
                        上面代码的两种写法，比较后可以发现，rest 参数的写法更自然也更简洁。
                        
                        arguments对象不是数组，而是一个类似数组的对象。
                        所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。
                        rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。





